// $Id$

#include <getopt.h>
#include <pcap.h>
#include <stdarg.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

extern "C" {
#include <libhilti.h>
}

const char* Trace;
const char* Filter;
const char* Bitcode;
int Profile = 0;
int Dummy = 0;

unsigned long HdrSize = 14; // Ethernet

pcap_t* Pcap = 0;
struct bpf_program* Bpf = 0;
unsigned long PacketCounter = 0;

const char* fmt_log(const char* prefix, const char* fmt, va_list ap)
{
    const int SIZE = 32768;
    static char buffer[SIZE];
    int n = 0;

    n += snprintf(buffer + n, SIZE - n, "%s: ", prefix);
    n += vsnprintf(buffer + n, SIZE - n, fmt, ap);

    strcat(buffer + n, "\n");

    return buffer;
}

void error(const char* fmt, ...)
{
    va_list ap;
    va_start(ap, fmt);
    const char* msg = fmt_log("error", fmt, ap);
    va_end(ap);
    fputs(msg, stdout);
    exit(1);
}


void readBitcode()
{
}

void setFilter()
{
    Bpf = new bpf_program;

    if ( pcap_compile(Pcap, Bpf, const_cast<char*>(Filter), 1, 0) < 0 )
        error("can't compile %s: %s", Filter, pcap_geterr(Pcap));
}

void pcapOpen()
{
    static char errbuf[PCAP_ERRBUF_SIZE];

    Pcap = pcap_open_offline(const_cast<char*>(Trace), errbuf);

    if ( ! Pcap )
        error("%s", errbuf);

    int dl = pcap_datalink(Pcap);
    if ( dl != DLT_EN10MB )
        error("unknown data link type 0x%x", dl);

    if ( Filter )
        setFilter();
}

inline uint64_t rdtsc()
{
    unsigned int lo, hi;
    __asm__ __volatile__("rdtsc" : "=a"(lo), "=d"(hi));
    return ((uint64_t)hi << 32) | lo;
}

uint64_t cycles = 0;

bool pcapNext()
{
    struct pcap_pkthdr* hdr;
    const u_char* data;
    int result;

    result = pcap_next_ex(Pcap, &hdr, &data);

    if ( result < 0 )
        // error("no more input");
        return false;

    if ( result == 0 )
        return false;

    // Do an extra copy and a bytes obj here to compare with HILTI, which
    // does so as well.
    size_t len = hdr->caplen - HdrSize;
    int8_t* buffer = (int8_t*)hlt_malloc_no_init(len);
    memcpy((char*)buffer, data + HdrSize, len);

    hlt_exception* excpt = 0;
    hlt_execution_context* ctx = 0; // hlt_global_execution_context();
    hlt_bytes* b = hlt_bytes_new_from_data(buffer, len, &excpt, ctx);
    GC_DTOR(b, hlt_bytes);

    int match = 0;

    if ( ! Dummy ) {
        uint64_t n = rdtsc();
        match = pcap_offline_filter(Bpf, hdr, data);
        cycles += (rdtsc() - n);
    }

    if ( match )
        ++PacketCounter;

    return true;
}

void pcapClose()
{
    pcap_close(Pcap);
}

void usage()
{
    printf(
        "pktcnt [Options] <input file>\n"
        "\n"
        "  -r| --readfile <trace>         Trace file to read\n"
        "  -f| --filter <filter>          BPF filter for filtering with libpcap\n"
        "  -b| --bitcode <secs>           Bitcode file generated by bpf2hlt + hilti-build\n"
        "  -P| --profile                  Enable HILTI profiling\n"
        "\n");

    exit(1);
}

static struct option long_options[] = {{"filter", required_argument, 0, 'f'},
                                       {"bitcode", required_argument, 0, 'b'},
                                       {"readfile", required_argument, 0, 't'},
                                       {"profile", required_argument, 0, 'P'},
                                       {0, 0, 0, 0}};

int main(int argc, char** argv)
{
    while ( 1 ) {
        char c = getopt_long(argc, argv, "f:b:r:Pd", long_options, 0);

        if ( c == -1 )
            break;

        switch ( c ) {
        case 'f':
            Filter = optarg;
            break;

        case 'd':
            ++Dummy;
            break;

        case 'b':
            Bitcode = optarg;
            break;

        case 'r':
            Trace = optarg;
            break;

        case 'P':
            Profile = 1;
            break;

        default:
            usage();
        }
    }

    if ( optind != argc )
        usage();

    if ( ! Trace )
        error("need -r");

    if ( ! (Filter || Bitcode) )
        error("need either -f or -b");

    if ( (Filter && Bitcode) )
        error("can only have one of -f or -b");

    if ( Bitcode )
        readBitcode();

    pcapOpen();

    PacketCounter = 0;

    fprintf(stderr, "pcap loop ...\n");

    while ( pcapNext() )
        ;

    pcapClose();

    fprintf(stdout, "packets %lu\n", PacketCounter);

    if ( Dummy )
        fprintf(stderr, "stdnofilter cycles %lu\n", cycles);
    else
        fprintf(stderr, "std cycles %lu\n", cycles);

    return 0;
}
