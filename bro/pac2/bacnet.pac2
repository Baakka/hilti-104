module BACnet;

import Bro;

# This module implements a BACnet parser.
# 
# When used on IP, BACnet is a protocol, which is layered on top
# of UDP.
# When used with IP, the outmost layer of a BACnet packet is the
# BACnet Virtual Link Layer (BVLL), which supports a number of different
# Virtual Link Control Functions (BVLC).
# 
# When the BVLL layer is used to sent a higher level message, it wraps
# a BACnet Network Protocol Data Unit (NPDU). This layer concerns itself
# with the routing (and so on) of BACnet messages. A NPDU message can either
# contain different NPDU Message Types, mostly concerning routing. A NPDU
# can also wrap a BACnet Application Protocol Data Unit (APDU).
#
# The APDU layer basically gets all messages that have nothing to do with routing.
# ASN.1 decoding is needed starting at this layer.

# Todo: add vendor IDs. Current list of BACnet vendor IDs is available at 
# http://www.bacnet.org/VendorID/BACnet%20Vendor%20IDs.htm
#
# vim search-replace for enums: s/^\(.*\) (\(\d*\).*/  \1 = \2,/

type BVLC_function = enum {
  # message distribution
  Original-Unicast-NPDU = 0x0A,
  Original-Broadcast-NPDU = 0x0B,
  Distribute-Broadcast-To-Network = 0x09,
  Forwarded-NPDU = 0x04,
  # bbmd broadcast distribution & foreign device table management
  Secure-BVLL = 0x0C,
  BVLC-Result = 0x00,
  Write-BDT = 0x01,
  Read-BDT = 0x02,
  Read-BDT-ACK= 0x03,
  Register-FD = 0x05,
  Read-FDT = 0x06,
  Read-FDT-ACK = 0x07,
  Delete-FDT-Entry = 0x08
};

export type Message = unit {
  # outer protocol exposed to UDP is BVLC
  tpe: uint8(0x81);
  func: uint8 &convert=BVLC_function($$);
  len: uint16;

  switch ( self.func ) {
   BVLC_function::Original-Unicast-NPDU,
   BVLC_function::Original-Broadcast-NPDU,
   BVLC_function::Distribute-Broadcast-To-Network -> npdu: NPDU(self.len - 4);
   BVLC_function::Forwarded-NPDU -> {
     originator: addr &ipv4;
     originator_port: uint16;
     npdu: NPDU(self.len - 10); # 4 bytes header + IP Address + port
   }
   BVLC_function::BVLC-Result,
   BVLC_function::Write-BDT,
   BVLC_function::Read-BDT,
   BVLC_function::Read-BDT-ACK,
   BVLC_function::Register-FD,
   BVLC_function::Read-FDT,
   BVLC_function::Read-FDT-ACK,
   BVLC_function::Delete-FDT-Entry -> bbmd: BBMD( self.func, self.len - 4 );
   # BVLC_function::Secure-BVLL Not yet supported, probably not used
  };

  on %done { print self; }
};

type BVLC_result = enum {
  Success = 0x0000,
  Write-BDT-NAK = 0x0010,
  Read-BDT-NAK = 0x0020,
  Register-FD-NAK = 0x0030,
  Read-FDT-NAK = 0x0040,
  Delete-FDT-NAK = 0x0050,
  Distribute-Broadcast-To-Network-NAK = 0x0060
};

# Broadcast Distribution Table. Due to the fact that BACnet cannot
# trust the underlying IP network do to broadcasting right, it does
# it itself.
#
# Each BACnet/IP Broadcast Management Device (BBMD) has a Broadcast
# Distribution table which contains the network addresses to which
# broadcasts are forwarded.
type BDT_entry = unit {
  address: addr &ipv4;
  address_port: uint16;
  mask: uint32;
};

# Foreign Device Table, also held by a BBMD. Foreign devices are
# devices that belong to a BACnet network, but reside on a different
# IP subnet as the other devices forming the subnet.
type FDT_entry = unit {
  address: addr &ipv4;
  address_port: uint16;
  ttl: uint16;
  time_remaining: uint16;
};

type BBMD = unit (func: BVLC_function, len: uint16) {
  switch ( func ) {
   BVLC_function::BVLC-Result -> bvlc_result: uint16 &convert=BVLC_result($$);
   BVLC_function::Read-BDT-ACK,
   BVLC_function::Write-BDT -> bdts: list<BDT_entry> &length=len/10;
   BVLC_function::Read-FDT,
   BVLC_function::Read-BDT -> : void;
   BVLC_function::Register-FD -> ttl: uint16;
   BVLC_function::Read-FDT-ACK,
   BVLC_function::Delete-FDT-Entry -> fdts: list<FDT_entry> &length=len/10;
  };
};

type NPDU_type = enum {
  Who-Is-Router-To-Network = 0x00,
  I-Am-Router-To-Network = 0x01,
  I-Could-Be-Router-To-Network = 0x02,
  Reject-Message-To-Network = 0x03,
  Router-Busy-To-Network = 0x04,
  Router-Available-To-Network = 0x05,
  Initialize-Routing-Table = 0x06,
  Initialize-Routing-Table-Ack = 0x07,
  Establish-Connection-To-Network = 0x08,
  Disconnect-Connection-To-Network = 0x09,
  Challenge-Request = 0x0A,
  Security-Payload = 0x0B,
  Security-Response = 0x0C,
  Request-Key-Update = 0x0D,
  Update-Key-Set = 0x0E,
  Update-Distribution-Key = 0x0F,
  Request-Master-Key = 0x10,
  Set-Master-Key = 0x11,
  What-Is-Network-Number = 0x12,
  Network-Numer-Is = 0x13
};

type NPDU_priority = enum {
  Normal = 0,
  Urgent = 1,
  Critical = 2,
  Life-Safety = 3
};

type NPDU = unit(len: uint16) {
  var priority: NPDU_priority;

  var head_length: uint16 = 2; # version + control

  version: uint8; # should be 0x1, but wireshark trace also has 10?
  control : bitfield(8) {
    priority: 0..1;
    der: 2;
    source: 3;
    reserved1: 4;
    destination: 5;
    reserved2: 6;
    nlmessage: 7;
  } {
    self.priority = NPDU_priority(self.control.priority);
  }

  dnet: uint16 if ( self.control.destination == 1 ) {
    self.head_length = self.head_length + 2;
  }
  dlen: uint8 if ( self.control.destination == 1 ) {
    self.head_length = self.head_length + 1;
  }
  dadr: bytes &length=self.dlen if ( self.control.destination == 1 ) {
    self.head_length = self.head_length + self.dlen;
  }
  snet: uint16 if ( self.control.source == 1 ) {
    self.head_length = self.head_length + 2;
  }
  slen: uint8 if ( self.control.source == 1 ) {
    self.head_length = self.head_length + 1;
  }
  sadr: bytes &length=self.slen if ( self.control.source == 1 ) {
    self.head_length = self.head_length + self.slen;
  }
  hop_count: uint8 if ( self.control.destination == 1) {
    self.head_length = self.head_length + 1;
  }
  message_type: uint8 &convert=NPDU_type($$) if ( self.control.nlmessage == 1 ) {
    self.head_length = self.head_length + 1;
  }

  npdu_message: NPDU_message( (len - self.head_length), self.message_type) if ( self.control.nlmessage == 1 );

  # if nlmessage == 0, APDU follows
  apdu: APDU( len - self.head_length ) if ( self.control.nlmessage == 0 );
};

type NPDU_Reject_reason = enum {
  Other = 0,
  No_route = 1,
  Router_busy = 2,
  Unknown_message_type = 3,
  Message_too_long = 4,
  Security_error = 5,
  Addressing_error = 6
};


type NPDU_message = unit(len: uint16, t: NPDU_type) {
  # len only is remaining length
  switch ( t ) {
    NPDU_type::Who-Is-Router-To-Network,
    NPDU_type::Disconnect-Connection-To-Network -> dnets: list<uint16> &length=1 if ( len >= 2 );
    NPDU_type::I-Am-Router-To-Network, 
    NPDU_type::Router-Busy-To-Network,
    NPDU_type::Router-Available-To-Network -> dnets: list<uint16> &length=len / 2;
    NPDU_type::I-Could-Be-Router-To-Network -> {
      dnets: list<uint16> &length=1;
      performance_index: uint8;
    }
    NPDU_type::Reject-Message-To-Network -> {
      reason: uint8 &convert=NPDU_Reject_reason($$);
      dnets: list<uint16> &length=1;
    }
    NPDU_type::Establish-Connection-To-Network -> {
      dnets: list<uint16> &length=1;
      termination_time: uint8;
    }
    NPDU_type::What-Is-Network-Number -> : void; # empty packet
    NPDU_type::Network-Numer-Is -> {
      network_number: uint16;
      learned: uint8;
    }
    NPDU_type::Initialize-Routing-Table,
    NPDU_type::Initialize-Routing-Table-Ack -> {
      number_ports: uint8 if ( len > 0 );
      routing_entries: list<NPDU_routing_entry> &length=1 if ( len > 0 );
    }
  };
};

type NPDU_routing_entry = unit {
  dnet: uint16;
  portId: uint8;
  portInfo_len: uint8;
  portInfo: bytes &length=self.portInfo_len;
};

type PDU_type = enum {
  ConfirmedRequest = 0,
  Unconfirmed-Request = 1,
  SimpleAck = 2,
  ComplexAck = 3,
  SegmentAck = 4,
  Error = 5,
  Reject = 5,
  Abort = 7
};

type APDU = unit(len: uint16) {
  # ok, the first 4 bits contain the actual message type - but we need them later.
  head: bytes &length = 1;
  var tpe: PDU_type;
  tpe_raw: uint8 &parse(self.head) {
    self.tpe_raw = (self.tpe_raw & 0xF0) >> 4;
    self.tpe = PDU_type(self.tpe_raw);
  }

  switch ( self.tpe ) {
    PDU_type::ConfirmedRequest -> confirmed_request: PDU_confirmedRequest(self.head, len);
    PDU_type::Unconfirmed-Request -> unconfirmed_request: PDU_unconfirmedRequest(len);
    PDU_type::SimpleAck -> simple_ack: PDU_simpleACK;
    PDU_type::ComplexAck -> complex_ack: PDU_complexAck(self.head);
    PDU_type::Error -> error: PDU_error;
    PDU_type::Reject -> reject: PDU_reject;
    PDU_type::Abort -> abort: PDU_abort(self.head);
  };

};

type BACnetConfirmedServiceChoice = enum {
  # Alarm and Event Services
  acknowledgeAlarm = 0,
  confirmedCOVNotification = 1,
  confirmedEventNotification = 2,
  getAlarmSummary = 3,
  getEnrollmentSummary = 4,
  getEventInformation = 29,
  subscribeCOV = 5,
  subscribeCOVProperty = 28,
  lifeSafetyOperation = 27,
  # File Access Services
  atomicReadFile = 6,
  atomicWriteFile = 7,
  # Object Access Services
  addListElement = 8,
  removeListElement = 9,
  createObject = 10,
  deleteObject = 11,
  readProperty = 12,
  readPropertyMultiple = 14,
  readRange = 26,
  writeProperty = 15,
  writePropertyMultiple = 16,
  # Remote Device Management Services
  deviceCommunicationControl = 17,
  confirmedPrivateTransfer = 18,
  confirmedTextMessage = 19,
  reinitializeDevice = 20,
  # Virtual Terminal Services
  vtOpen = 21,
  vtClose = 22,
  vtData = 23
};

type PDU_confirmedRequest = unit(head: bytes, len: uint16) {
  head1 : bitfield(8) {
    segmented-response-accepted: 1;
    more-follows: 2;
    segmented-message: 3;
    tpe: 4..7;
  } &parse(head);
  head2: bitfield(8) {
    max-APDU-length-accepted: 0..3;
    max-segments-accepted: 4..6;
  };

  invokeID: uint8;
  sequence_number: uint8 if ( self.head1.segmented-message == 1 );
  proposed_window_size: uint8 if ( self.head1.segmented-message == 1 );
  confirmed_service_choice: uint8 &convert=BACnetConfirmedServiceChoice($$);
  # variable part following - need standard for decoding.
};

type BACnetUnconfirmedServiceChoice = enum {
  i-Am = 0,
  i-Have = 1,
  unconfirmedCOVNotification = 2,
  unconfirmedEventNotification = 3,
  unconfirmedPrivateTransfer = 4,
  unconfirmedTextMessage = 5,
  timeSynchronization = 6,
  who-Has = 7,
  who-Is = 8,
  utcTimeSynchronization = 9,
  writeGroup = 10
};

type PDU_unconfirmedRequest = unit(len: uint16) {
  service_choice: uint8 &convert=BACnetUnconfirmedServiceChoice($$);
  # Following - variable part. Need standard to look up encoding.

  switch ( self.service_choice ) {
    BACnetUnconfirmedServiceChoice::i-Am -> i_am: PDU_i_am;    
    BACnetUnconfirmedServiceChoice::who-Is -> who_is: PDU_who_is(len - 2);
    * -> : void;
  };
};

type PDU_who_is = unit(len: uint16) {
  tag: BACnetTag if ( len > 0 ); # context specific - has to be tag 0
  deviceInstanceRangeLowLimit: uint16 if ( len > 0 );
  tag2: BACnetTag if ( len > 0 ); # context specific - has to be tag 1
  deviceInstanceRangeHighLimit: uint16 if ( len > 0);
};

type PDU_i_am = unit {
  iAmDeviceIdentifier: BACnetMessage; # oid 
  maxAPDULengthAccepted: BACnetMessage; # unsigned 
  segmentationSupported: BACnetMessage; # BACnetSegmentation
  vendorID: BACnetMessage; # unsigned16
};

type PDU_simpleACK = unit {
  invokeID: uint8;
  service_choice: uint8 &convert=BACnetConfirmedServiceChoice($$);
};

type PDU_complexAck = unit(head_raw: bytes) {
  head : bitfield(8) {
    more-follows: 2;
    segmented-message: 3;
    tpe: 4..7;
  } &parse(head_raw);
  invokeID: uint8;
  sequence_number: uint8 if ( self.head.segmented-message == 1 );
  proposed_window_size: uint8 if ( self.head.segmented-message == 1 );
  confirmed_service_choice: uint8 &convert=BACnetConfirmedServiceChoice($$); 
  # Following - variable part. Need standard to look up encoding.
};

type PDU_error = unit {
  invokeID: uint8;
  error-class: uint8;
  error-code: uint8;
  # conversion codes -> standard;
};

type BACnetRejectReason = enum {
  other = 0,
  buffer-overflow = 1,
  inconsistent-parameters = 2,
  invalid-parameter-data-type = 3,
  invalid-tag = 4,
  missing-required-parameter = 5,
  parameter-out-of-range = 6,
  too-many-arguments = 7,
  undefined-enumeration = 8,
  unrecognized-service = 9
};

type PDU_reject = unit {
  invokeID: uint8;
  reject_reason: uint8 &convert=BACnetAbortReason($$);
};

type BACnetAbortReason = enum {
  other = 0,
  buffer-overflow = 1,
  invalid-apdu-in-this-state = 2,
  preempted-by-higher-priority-task = 3,
  segmentation-not-supported = 4,
  security-error = 5,
  insufficient-security = 6,
  window-size-out-of-range = 7,
  application-exceeded-reply-time = 8,
  out-of-resources = 9,
  tsm-timeout = 10,
  apdu-too-long = 11
};

type PDU_abort = unit(head_raw: bytes) { # page 624
  head : bitfield(8) {
    server: 0;
    tpe: 4..7;
  } &parse(head_raw);
  invokeID: uint8;
  abort_reason: uint8 &convert=BACnetAbortReason($$); # pg. 652
};

type ASN1Class = enum {
  UNIVERSAL = 0,
  APPLICATION = 1,
  context-specific = 2,
  PRIVATE = 3
};

type BACnetType = enum {
  NULL = 0,
  BOOLEAN = 1,
  UnsignedInteger = 2,
  Integer = 3,
  Real = 4,
  Double = 5,
  OctetString = 6,
  CharacterString = 7,
  BitString = 8,
  Enumerated = 9,
  Date = 10,
  Time = 11,
  BACnetObjectIdentifier = 12
};

type BACnetTag = unit {
  var tpe: BACnetType;
  var class: ASN1Class;

  data : bitfield(8) {
     lvt: 0..2;
     class: 3;
     tag: 4..7;
  } &bitorder=BinPAC::BitOrder::LSB0;

  tag: uint8 if ( self.data.tag == 0xF );
  lvt: uint8 if ( self.data.lvt == 0x5 );

  on %done { 
    if ( self.data.tag != 0xF ) {
      self.tag = self.data.tag;
    }
    if ( self.data.lvt != 0x5 ) {
      self.lvt = self.data.lvt;
    }
    self.tpe = BACnetType(self.tag);
    self.class = ASN1Class(self.data.class + 1); # bacnet only has application / context-specific
  }
};

type BACnetObjectType = enum { 
  alert-enrollment = 52,
  access-credential = 32,
  access-door = 30,
  access-point = 33,
  access-rights = 34,
  access-user = 35,
  access-zone = 36,
  accumulator = 23,
  analog-input = 0,
  analog-output = 1,
  analog-value = 2,
  averaging = 18,
  binary-input = 3,
  binary-output = 4,
  binary-value = 5,
  bitstring-value = 39,
  calendar = 6,
  channel = 53,
  characterstring-value = 40,
  command = 7,
  credential-data-input = 37,
  date-pattern-value = 41,
  date-value = 42,
  datetime-pattern-value = 43,
  datetime-value = 44,
  device = 8,
  event-enrollment = 9,
  event-log = 25,
  bacnet-file = 10,  # original name: file
  global-group = 26,
  group = 11,
  integer-value = 45,
  large-analog-value = 46,
  life-safety-point = 21,
  life-safety-zone = 22,
  lighting-output = 54,
  load-control = 28,
  loop = 12,
  multi-state-input = 13,
  multi-state-output = 14,
  multi-state-value = 19,
  network-security = 38,
  notification-class = 15,
  notification-forwarder = 51,
  octetstring-value = 47,
  positive-integer-value = 48,
  program = 16,
  pulse-converter = 24,
  schedule = 17,
  structured-view = 29,
  time-pattern-value = 49,
  time-value = 50,
  trend-log = 20,
  trend-log-multiple = 27
};

# Fixme: need to get the type mapping from somewhere, probably the standard...
type BACnetObjectIdentifier = unit {
  var tpe: BACnetObjectType;

  data: bitfield(32) {
    instanceNumer: 0..21;
    tpe: 22..31;
  } { 
    self.tpe = BACnetObjectType(self.data.tpe);
  }
};

type BACnetMessage = unit {
  tag: BACnetTag;

  var boolean: uint16;

  switch ( self.tag.tpe ) {
    BACnetType::NULL -> : void;
    BACnetType::BOOLEAN -> : void { self.boolean = self.tag.data.lvt; }
    BACnetType::UnsignedInteger,
    BACnetType::Enumerated -> unsigned: bytes &length=self.tag.data.lvt &convert=$$.to_uint(BinPAC::ByteOrder::Network);
    BACnetType::Integer -> signed: bytes &length=self.tag.data.lvt &convert=$$.to_int(BinPAC::ByteOrder::Network);
    BACnetType::OctetString -> octets: bytes &length=self.tag.data.lvt;
    BACnetType::CharacterString -> characters: BACnetCharacterString(self.tag.data.lvt);
    BACnetType::BitString -> bistring: BACnetBitString(self.tag.data.lvt);
    BACnetType::Date -> date: BACnetDate;
    BACnetType::Time -> btime: BACnetTime;
    BACnetType::BACnetObjectIdentifier -> oid: BACnetObjectIdentifier;
    
    # Fixme: Real, double. I don't think Binpac++ can read those from wire yet.
    BACnetType::Real -> : bytes &length = 4;
    BACnetType::Double -> : bytes &length = 8;
  };
};

type BACnetDate = unit {
  # a value of 0xFF in any field means wildcard.

  var year: uint16;
  year_raw: uint8 {
    if ( self.year_raw != 0xFF ) {
      self.year = self.year_raw;
      self.year = self.year + 1900;
    } else {
      self.year = 0; # unspecified
    }
  }

  month: uint8;
  day: uint8;
  weekday: uint8; # monday = 1 
};

type BACnetTime = unit {
  # a value of 0xFF in any field means wildcard.
  hour: uint8;
  minute: uint8;
  second: uint8;
  centisecond: uint8;
};
  

type BACnetCharacterStringType = enum {
  UTF8 = 0,
  DBCS = 1,
  JISX0208 = 2,
  UCS4 = 3,
  UCS2 = 4,
  ISO00591 = 5
};

type BACnetCharacterString = unit(len: uint16) {
  tpe: uint8 &convert=BACnetCharacterStringType($$);

  switch ( self.tpe ) {
    # LE and BE could be switched, not quite sure...
    BACnetCharacterStringType::UTF8 -> value: bytes &length=(len - 1) &convert=$$.decode(BinPAC::Charset::UTF8); 
    BACnetCharacterStringType::UCS2 -> value: bytes &length=(len - 1) &convert=$$.decode(BinPAC::Charset::UTF16BE); 
    BACnetCharacterStringType::UCS4 -> value: bytes &length=(len - 1) &convert=$$.decode(BinPAC::Charset::UTF32BE); 
    * -> value: bytes &length=(len - 1) &convert=$$.decode(BinPAC::Charset::ASCII); # FIXME! DBCS, JOSX0208, ISO885901
  };
  
};

type BACnetBitString = unit(len: uint16) {
   unused_bits: uint8;
   value_bits: bytes &length=(len - 1);
};

