module BACnet;

import Bro;

# This module implements a BACnet parser.
# 
# When used on IP, BACnet is a protocol, which is layered on top
# of UDP.
# When used with IP, the outmost layer of a BACnet packet is the
# BACnet Virtual Link Layer (BVLL), which supports a number of different
# Virtual Link Control Functions (BVLC).
# 
# When the BVLL layer is used to sent a higher level message, it wraps
# a BACnet Network Protocol Data Unit (NPDU). This layer concerns itself
# with the routing (and so on) of BACnet messages. A NPDU message can either
# contain different NPDU Message Types, mostly concerning routing. A NPDU
# can also wrap a BACnet Application Protocol Data Unit (APDU).
#
# The APDU layer basically gets all messages that have nothing to do with routing.
# ASN.1 decoding is needed starting at this layer.

# Todo: add vendor IDs. Current list of BACnet vendor IDs is available at 
# http://www.bacnet.org/VendorID/BACnet%20Vendor%20IDs.htm
#
# vim search-replace for enums: s/^\(.*\) (\(\d*\).*/  \1 = \2,/

type BACnetPropertyIdentifier = enum { 
  absentee-limit = 244,
  accepted-modes = 175,
  access-alarm-events = 245,
  access-doors = 246,
  access-event = 247,
  access-event-authentication-factor = 248,
  access-event-credential = 249,
  access-event-tag = 322,
  access-event-time = 250,
  access-transaction-events = 251,
  accompaniment = 252,
  accompaniment-time = 253,
  ack-required = 1,
  acked-transitions = 0,
  action = 2,
  action-text = 3,
  activation-time = 254,
  active-authentication-policy = 255,
  active-cov-subscriptions = 152,
  active-text = 4,
  active-vt-sessions = 5,
  actual-shed-level = 212,
  adjust-value = 176,
  alarm-value = 6,
  alarm-values = 7,
  align-intervals = 193,
  all = 8,
  all-writes-successful = 9,
  allow-group-delay-inhibit = 365,
  apdu-segment-timeout = 10,
  apdu-timeout = 11,
  application-software-version = 12,
  archive = 13,
  assigned-access-rights = 256,
  attempted-samples = 124,
  authentication-factors = 257,
  authentication-policy-list = 258,
  authentication-policy-names = 259,
  authentication-status = 260,
  authorization-exemptions = 364,
  authorization-mode = 261,
  auto-slave-discovery = 169,
  average-value = 125,
  backup-and-restore-state = 338,
  backup-failure-timeout = 153,
  backup-preparation-time = 339,
  base-device-security-policy = 327,
  belongs-to = 262,
  bias = 14,
  bit-mask = 342,
  bit-text = 343,
  blink-warn-enable = 373,
  buffer-size = 126,
  change-of-state-count = 15,
  change-of-state-time = 16,
  channel-number = 366,
  client-cov-increment = 127,
  configuration-files = 154,
  control-groups = 367,
  controlled-variable-reference = 19,
  controlled-variable-units = 20,
  controlled-variable-value = 21,
  count = 177,
  count-before-change = 178,
  count-change-time = 179,
  cov-increment = 22,
  cov-period = 180,
  cov-resubscription-interval = 128,
  covu-period = 349,
  covu-recipients = 350,
  credential-disable = 263,
  credential-status = 264,
  credentials = 265,
  credentials-in-zone = 266,
  database-revision = 155,
  date-list = 23,
  daylight-savings-status = 24,
  days-remaining = 267,
  deadband = 25,
  default-fade-time = 374,
  default-ramp-rate = 375,
  default-step-increment = 376,
  derivative-constant = 26,
  derivative-constant-units = 27,
  description = 28,
  description-of-halt = 29,
  device-address-binding = 30,
  device-type = 31,
  direct-reading = 156,
  distribution-key-revision = 328,
  do-not-hide = 329,
  door-alarm-state = 226,
  door-extended-pulse-time = 227,
  door-members = 228,
  door-open-too-long-time = 229,
  door-pulse-time = 230,
  door-status = 231,
  door-unlock-delay-time = 232,
  duty-window = 213,
  effective-period = 32,
  egress-time = 377,
  egress-active = 386,
  elapsed-active-time = 33,
  entry-points = 268,
  enable = 133,
  error-limit = 34,
  event-algorithm-inhibit = 354,
  event-algorithm-inhibit-ref = 355,
  event-detection-enable = 353,
  event-enable = 35,
  event-message-texts = 351,
  event-message-texts-config = 352,
  event-state = 36,
  event-time-stamps = 130,
  event-type = 37,
  event-parameters = 83,
  exception-schedule = 38,
  execution-delay = 368,
  exit-points = 269,
  expected-shed-level = 214,
  expiry-time = 270,
  extended-time-enable = 271,
  failed-attempt-events = 272,
  failed-attempts = 273,
  failed-attempts-time = 274,
  fault-parameters = 358,
  fault-type = 359,
  fault-values = 39,
  feedback-value = 40,
  file-access-method = 41,
  file-size = 42,
  file-type = 43,
  firmware-revision = 44,
  full-duty-baseline = 215,
  global-identifier = 323,
  group-members = 345,
  group-member-names = 346,
  high-limit = 45,
  inactive-text = 46,
  in-process = 47,
  in-progress = 378,
  input-reference = 181,
  instance-of = 48,
  instantaneous-power = 379,
  integral-constant = 49,
  integral-constant-units = 50,
  interval-offset = 195,
  is-utc = 344,
  key-sets = 330,
  last-access-event = 275,
  last-access-point = 276,
  last-credential-added = 277,
  last-credential-added-time = 278,
  last-credential-removed = 279,
  last-credential-removed-time = 280,
  last-key-server = 331,
  last-notify-record = 173,
  last-priority = 369,
  last-restart-reason = 196,
  last-restore-time = 157,
  last-use-time = 281,
  life-safety-alarm-values = 166,
  lighting-command = 380,
  lighting-command-default-priority = 381,
  limit-enable = 52,
  limit-monitoring-interval = 182,
  list-of-group-members = 53,
  list-of-object-property-references = 54,
  local-date = 56,
  local-forwarding-only = 360,
  local-time = 57,
  location = 58,
  lock-status = 233,
  lockout = 282,
  lockout-relinquish-time = 283,
  log-buffer = 131,
  log-device-object-property = 132,
  log-interval = 134,
  logging-object = 183,
  logging-record = 184,
  logging-type = 197,
  low-limit = 59,
  maintenance-required = 158,
  manipulated-variable-reference = 60,
  manual-slave-address-binding = 170,
  masked-alarm-values = 234,
  maximum-output = 61,
  maximum-value = 135,
  maximum-value-timestamp = 149,
  max-actual-value = 382,
  max-apdu-length-accepted = 62,
  max-failed-attempts = 285,
  max-info-frames = 63,
  max-master = 64,
  max-pres-value = 65,
  max-segments-accepted = 167,
  member-of = 159,
  member-status-flags = 347,
  members = 286,
  minimum-off-time = 66,
  minimum-on-time = 67,
  minimum-output = 68,
  minimum-value = 136,
  minimum-value-timestamp = 150,
  min-actual-value = 383,
  min-pres-value = 69,
  mode = 160,
  model-name = 70,
  modification-date = 71,
  muster-point = 287,
  negative-access-rules = 288,
  network-access-security-policies = 332,
  node-subtype = 207,
  node-type = 208,
  notification-class = 17,
  notification-threshold = 137,
  notify-type = 72,
  number-of-apdu-retries = 73,
  number-of-authentication-policies = 289,
  number-of-states = 74,
  object-identifier = 75,
  object-list = 76,
  object-name = 77,
  object-property-reference = 78,
  object-type = 79,
  occupancy-count = 290,
  occupancy-count-adjust = 291,
  occupancy-count-enable = 292,
  occupancy-lower-limit = 294,
  occupancy-lower-limit-enforced = 295,
  occupancy-state = 296,
  occupancy-upper-limit = 297,
  occupancy-upper-limit-enforced = 298,
  operation-expected = 161,
  optional = 80,
  out-of-service = 81,
  output-units = 82,
  packet-reorder-time = 333,
  passback-mode = 300,
  passback-timeout = 301,
  polarity = 84,
  port-filter = 363,
  positive-access-rules = 302,
  power = 384,
  prescale = 185,
  present-value = 85,
  priority = 86,
  priority-array = 87,
  priority-for-writing = 88,
  process-identifier = 89,
  process-identifier-filter = 361,
  profile-name = 168,
  program-change = 90,
  program-location = 91,
  program-state = 92,
  property-list = 371,
  proportional-constant = 93,
  proportional-constant-units = 94,
  protocol-object-types-supported = 96,
  protocol-revision = 139,
  protocol-services-supported = 97,
  protocol-version = 98,
  pulse-rate = 186,
  read-only = 99,
  reason-for-disable = 303,
  reason-for-halt = 100,
  recipient-list = 102,
  records-since-notification = 140,
  record-count = 141,
  reliability = 103,
  reliability-evaluation-inhibit = 357,
  relinquish-default = 104,
  requested-shed-level = 218,
  requested-update-interval = 348,
  required = 105,
  resolution = 106,
  restart-notification-recipients = 202,
  restore-completion-time = 340,
  restore-preparation-time = 341,
  scale = 187,
  scale-factor = 188,
  schedule-default = 174,
  secured-status = 235,
  security-pdu-timeout = 334,
  security-time-window = 335,
  segmentation-supported = 107,
  serial-number = 372,
  setpoint = 108,
  setpoint-reference = 109,
  setting = 162,
  shed-duration = 219,
  shed-level-descriptions = 220,
  shed-levels = 221,
  silenced = 163,
  slave-address-binding = 171,
  slave-proxy-enable = 172,
  start-time = 142,
  state-description = 222,
  state-text = 110,
  status-flags = 111,
  stop-time = 143,
  stop-when-full = 144,
  structured-object-list = 209,
  subordinate-annotations = 210,
  subordinate-list = 211,
  subscribed-recipients = 362,
  supported-formats = 304,
  supported-format-classes = 305,
  supported-security-algorithms = 336,
  system-status = 112,
  threat-authority = 306,
  threat-level = 307,
  time-delay = 113,
  time-delay-normal = 356,
  time-of-active-time-reset = 114,
  time-of-device-restart = 203,
  time-of-state-count-reset = 115,
  time-synchronization-interval = 204,
  time-synchronization-recipients = 116,
  total-record-count = 145,
  trace-flag = 308,
  tracking-value = 164,
  transaction-notification-class = 309,
  transition = 385,
  trigger = 205,
  units = 117,
  update-interval = 118,
  update-key-set-timeout = 337,
  update-time = 189,
  user-external-identifier = 310,
  user-information-reference = 311,
  user-name = 317,
  user-type = 318,
  uses-remaining = 319,
  utc-offset = 119,
  utc-time-synchronization-recipients = 206,
  valid-samples = 146,
  value-before-change = 190,
  value-set = 191,
  value-change-time = 192,
  variance-value = 151,
  vendor-identifier = 120,
  vendor-name = 121,
  verification-time = 326,
  vt-classes-supported = 122,
  weekly-schedule = 123,
  window-interval = 147,
  window-samples = 148,
  write-status = 370,
  zone-from = 320,
  zone-members = 165,
  zone-to = 321
# The special property identifiers all, optional, and required are reserved for use in the
# ReadPropertyMultiple service or services not defined in this standard.
#
# Enumerated values 0-511 are reserved for definition by ASHRAE. Enumerated values 512-4194303 may be used by
# others subject to the procedures and constraints described in Clause 23.
};

type BACnetEventType = enum {
  change-of-bitstring = 0,
  change-of-state = 1,
  change-of-value = 2,
  command-failure = 3,
  floating-limit = 4,
  out-of-range = 5,
  # complex-event-type = 6,
  # context tag 7 is deprecated
  change-of-life-safety = 8,
  extended = 9,
  buffer-ready = 10,
  unsigned-range = 11,
  # enumeration value 12 is reserved for future addenda
  access-event = 13,
  double-out-of-range = 14,
  signed-out-of-range = 15,
  unsigned-out-of-range = 16,
  change-of-characterstring = 17,
  change-of-status-flags = 18,
  change-of-reliability = 19,  
  none = 20
## Enumerated values 0-63 are reserved for definition by ASHRAE. Enumerated values
## 64-65535 may be used by others subject to the procedures and constraints described
## in Clause 23. It is expected that these enumerated values will correspond to the use of the
## complex-event-type CHOICE [6] of the BACnetNotificationParameters production.
};

type BACnetNotifyType = enum {
  alarm = 0,
  event = 1,
  ack-notification = 2
};

type BACnetEventState = enum {
  normal = 0,
  fault = 1,
  offnormal = 2,
  high-limit = 3,
  low-limit = 4,
  life-safety-alarm = 5
## Enumerated values 0-63 are reserved for definition by ASHRAE. Enumerated values
## 64-65535 may be used by others subject to the procedures and constraints described
## in Clause 23. The last enumeration used in this version is 5.
};

type BACnetLifeSafetyMode = enum {
  off = 0,
  bacnet-on = 1, # original: on
  test = 2,
  manned = 3,
  unmanned = 4,
  armed = 5,
  disarmed = 6,
  prearmed = 7,
  slow = 8,
  fast = 9,
  disconnected = 10,
  enabled = 11,
  disabled = 12,
  automatic-release-disabled = 13,
  default = 14
## Enumerated values 0-255 are reserved for definition by ASHRAE. Enumerated values
## 256-65535 may be used by others subject to procedures and constraints described in Clause 23.
};

type BACnetLifeSafetyOperation = enum {
  none = 0,
  silence = 1,
  silence-audible = 2,
  silence-visual = 3,
  reset = 4,
  reset-alarm = 5,
  reset-fault = 6,
  unsilence = 7,
  unsilence-audible = 8,
  unsilence-visual = 9
## Enumerated values 0-63 are reserved for definition by ASHRAE. Enumerated values
## 64-65535 may be used by others subject to procedures and constraints described in
## Clause 23.
};

type BACnetLifeSafetyState = enum {
  quiet = 0,
  pre-alarm = 1,
  alarm = 2,
  fault = 3,
  fault-pre-alarm = 4,
  fault-alarm = 5,
  not-ready = 6,
  active = 7,
  tamper = 8,
  test-alarm = 9,
  test-active = 10,
  test-fault = 11,
  test-fault-alarm = 12,
  holdup = 13,
  duress = 14,
  tamper-alarm = 15,
  abnormal = 16,
  emergency-power = 17,
  delayed = 18,
  blocked = 19,
  local-alarm = 20,
  general-alarm = 21,
  supervisory = 22,
  test-supervisory = 23
## Enumerated values 0-255 are reserved for definition by ASHRAE. Enumerated values
## 256-65535 may be used by others subject to procedures and constraints described in Clause 23.
};

type BACnetAccessEvent = enum {
  none = 0,
  granted = 1,
  muster = 2,
  passback-detected = 3,
  duress = 4,
  trace = 5,
  lockout-max-attempts = 6,
  lockout-other = 7,
  lockout-relinquished = 8,
  locked-by-higher-priority = 9,
  out-of-service = 10,
  out-of-service-relinquished = 11,
  accompaniment-by = 12,
  authentication-factor-read = 13,
  authorization-delayed = 14,
  verification-required = 15,
  no-entry-after-grant = 16,
## Enumerated values 128-511 are used for events which indicate that access has been denied.
  denied-deny-all = 128,
  denied-unknown-credential = 129,
  denied-authentication-unavailable = 130,
  denied-authentication-factor-timeout = 131,
  denied-incorrect-authentication-factor = 132,
  denied-zone-no-access-rights = 133,
  denied-point-no-access-rights = 134,
  denied-no-access-rights = 135,
  denied-out-of-time-range = 136,
  denied-threat-level = 137,
  denied-passback = 138,
  denied-unexpected-location-usage = 139,
  denied-max-attempts = 140,
  denied-lower-occupancy-limit = 141,
  denied-upper-occupancy-limit = 142,
  denied-authentication-factor-lost = 143,
  denied-authentication-factor-stolen = 144,
  denied-authentication-factor-damaged = 145,
  denied-authentication-factor-destroyed = 146,
  denied-authentication-factor-disabled = 147,
  denied-authentication-factor-error = 148,
  denied-credential-unassigned = 149,
  denied-credential-not-provisioned = 150,
  denied-credential-not-yet-active = 151,
  denied-credential-expired = 152,
  denied-credential-manual-disable = 153,
  denied-credential-lockout = 154,
  denied-credential-max-days = 155,
  denied-credential-max-uses = 156,
  denied-credential-inactivity = 157,
  denied-credential-disabled = 158,
  denied-no-accompaniment = 159,
  denied-incorrect-accompaniment = 160,
  denied-lockout = 161,
  denied-verification-failed = 162,
  denied-verification-timeout = 163,
  denied-other = 164
## Enumerated values 0-511 are reserved for definition by ASHRAE. Enumerated values
## 512-65535 may be used by others subject to the procedures and constraints described
## in Clause 23.
};

type BACnetAuthenticationFactorType = enum {
  undefined = 0,
  error = 1,
  custom = 2,
  simple-number16 = 3,
  simple-number32 = 4,
  simple-number56 = 5,
  simple-alpha-numeric = 6,
  aba-track2 = 7,
  wiegand26 = 8,
  wiegand37 = 9,
  wiegand37-facility = 10,
  facility16-card32 = 11,
  facility32-card32 = 12,
  fasc-n = 13,
  fasc-n-bcd = 14,
  fasc-n-large = 15,
  fasc-n-large-bcd = 16,
  gsa75 = 17,
  chuid = 18,
  chuid-full = 19,
  guid = 20,
  cbeff-A = 21,
  cbeff-B = 22,
  cbeff-C = 23,
  user-password = 24
};

type BACnetReliability = enum {
  no-fault-detected = 0,
  no-sensor = 1,
  over-range = 2,
  under-range = 3,
  open-loop = 4,
  shorted-loop = 5,
  no-output = 6,
  unreliable-other = 7,
  process-error = 8,
  multi-state-fault = 9,
  configuration-error = 10,
## enumeration value 11 is reserved for a future addendum
  communication-failure = 12,
  member-fault = 13,
  monitored-object-fault = 14,
  tripped = 15
## Enumerated values 0-63 are reserved for definition by ASHRAE. Enumerated values
## 64-65535 may be used by others subject to the procedures and constraints described
## in Clause 23.
};

type BVLC_function = enum {
  # message distribution
  Original-Unicast-NPDU = 0x0A,
  Original-Broadcast-NPDU = 0x0B,
  Distribute-Broadcast-To-Network = 0x09,
  Forwarded-NPDU = 0x04,
  # bbmd broadcast distribution & foreign device table management
  Secure-BVLL = 0x0C,
  BVLC-Result = 0x00,
  Write-BDT = 0x01,
  Read-BDT = 0x02,
  Read-BDT-ACK= 0x03,
  Register-FD = 0x05,
  Read-FDT = 0x06,
  Read-FDT-ACK = 0x07,
  Delete-FDT-Entry = 0x08
};

export type Message = unit {
  # outer protocol exposed to UDP is BVLC
  tpe: uint8(0x81);
  func: uint8 &convert=BVLC_function($$);
  len: uint16;

  switch ( self.func ) {
   BVLC_function::Original-Unicast-NPDU,
   BVLC_function::Original-Broadcast-NPDU,
   BVLC_function::Distribute-Broadcast-To-Network -> npdu: NPDU(self.len - 4);
   BVLC_function::Forwarded-NPDU -> {
     originator: addr &ipv4;
     originator_port: uint16;
     npdu: NPDU(self.len - 10); # 4 bytes header + IP Address + port
   }
   BVLC_function::BVLC-Result,
   BVLC_function::Write-BDT,
   BVLC_function::Read-BDT,
   BVLC_function::Read-BDT-ACK,
   BVLC_function::Register-FD,
   BVLC_function::Read-FDT,
   BVLC_function::Read-FDT-ACK,
   BVLC_function::Delete-FDT-Entry -> bbmd: BBMD( self.func, self.len - 4 );
   # BVLC_function::Secure-BVLL Not yet supported, probably not used
  };

  # on %done { print self; }
};

type BVLC_result = enum {
  Success = 0x0000,
  Write-BDT-NAK = 0x0010,
  Read-BDT-NAK = 0x0020,
  Register-FD-NAK = 0x0030,
  Read-FDT-NAK = 0x0040,
  Delete-FDT-NAK = 0x0050,
  Distribute-Broadcast-To-Network-NAK = 0x0060
};

# Broadcast Distribution Table. Due to the fact that BACnet cannot
# trust the underlying IP network do to broadcasting right, it does
# it itself.
#
# Each BACnet/IP Broadcast Management Device (BBMD) has a Broadcast
# Distribution table which contains the network addresses to which
# broadcasts are forwarded.
type BDT_entry = unit {
  address: addr &ipv4;
  address_port: uint16;
  mask: uint32;
};

# convert a BDT entry into a Bro tuple
tuple<addr, uint64, uint64> bro_bdt_entry(entry: BDT_entry) {
  return ( entry.address, cast<uint64>(entry.address_port), cast<uint64>(entry.mask) );
}

# Foreign Device Table, also held by a BBMD. Foreign devices are
# devices that belong to a BACnet network, but reside on a different
# IP subnet as the other devices forming the subnet.
type FDT_entry = unit {
  address: addr &ipv4;
  address_port: uint16;
  ttl: uint16;
  time_remaining: uint16;
};

# convert a FDT entry into a Bro tuple
tuple<addr, uint64, uint64, uint64> bro_fdt_entry(entry: FDT_entry) {
  return ( entry.address, cast<uint64>(entry.address_port), cast<uint64>(entry.ttl), cast<uint64>(entry.time_remaining) );
}

type BBMD = unit (func: BVLC_function, len: uint16) {
   # var bdts_brolist: list< tuple<addr, uint64, uint64> >;

  switch ( func ) {
   BVLC_function::BVLC-Result -> bvlc_result: uint16 &convert=BVLC_result($$);
   BVLC_function::Read-BDT-ACK,
   BVLC_function::Write-BDT -> bdts: list<BDT_entry> &length=len/10; # {
#                                 self.bdts_brolist = [ i for i in self.bdts ];
#                               }
   BVLC_function::Read-FDT,
   BVLC_function::Read-BDT -> : void;
   BVLC_function::Register-FD -> ttl: uint16;
   BVLC_function::Read-FDT-ACK,
   BVLC_function::Delete-FDT-Entry -> fdts: list<FDT_entry> &length=len/10;
  };
};

type NPDU_type = enum {
  Who-Is-Router-To-Network = 0x00,
  I-Am-Router-To-Network = 0x01,
  I-Could-Be-Router-To-Network = 0x02,
  Reject-Message-To-Network = 0x03,
  Router-Busy-To-Network = 0x04,
  Router-Available-To-Network = 0x05,
  Initialize-Routing-Table = 0x06,
  Initialize-Routing-Table-Ack = 0x07,
  Establish-Connection-To-Network = 0x08,
  Disconnect-Connection-To-Network = 0x09,
  Challenge-Request = 0x0A,
  Security-Payload = 0x0B,
  Security-Response = 0x0C,
  Request-Key-Update = 0x0D,
  Update-Key-Set = 0x0E,
  Update-Distribution-Key = 0x0F,
  Request-Master-Key = 0x10,
  Set-Master-Key = 0x11,
  What-Is-Network-Number = 0x12,
  Network-Numer-Is = 0x13
};

type NPDU_priority = enum {
  Normal = 0,
  Urgent = 1,
  Critical = 2,
  Life-Safety = 3
};

type NPDU = unit(len: uint16) {
  var priority: NPDU_priority;

  var head_length: uint16 = 2; # version + control

  version: uint8; # should be 0x1, but wireshark trace also has 10?
  control : bitfield(8) {
    priority: 0..1;
    der: 2;
    source: 3;
    reserved1: 4;
    destination: 5;
    reserved2: 6;
    nlmessage: 7;
  } {
    self.priority = NPDU_priority(self.control.priority);
  }

  dnet: uint16 if ( self.control.destination == 1 ) {
    self.head_length = self.head_length + 2;
  }
  dlen: uint8 if ( self.control.destination == 1 ) {
    self.head_length = self.head_length + 1;
  }
  dadr: bytes &length=self.dlen if ( self.control.destination == 1 ) {
    self.head_length = self.head_length + self.dlen;
  }
  snet: uint16 if ( self.control.source == 1 ) {
    self.head_length = self.head_length + 2;
  }
  slen: uint8 if ( self.control.source == 1 ) {
    self.head_length = self.head_length + 1;
  }
  sadr: bytes &length=self.slen if ( self.control.source == 1 ) {
    self.head_length = self.head_length + self.slen;
  }
  hop_count: uint8 if ( self.control.destination == 1) {
    self.head_length = self.head_length + 1;
  }
  message_type: uint8 &convert=NPDU_type($$) if ( self.control.nlmessage == 1 ) {
    self.head_length = self.head_length + 1;
  }

  npdu_message: NPDU_message( (len - self.head_length), self.message_type) if ( self.control.nlmessage == 1 );

  # if nlmessage == 0, APDU follows
  apdu: APDU( len - self.head_length ) if ( self.control.nlmessage == 0 );
};

# convert data present in all NPDUs into a NPDU_info record
#tuple<NPDU_priority, uint64, bytes, uint64, bytes, uint64, NPDU_type> bro_npdu_info(npdu: NPDU) {
#  return ( npdu.priority, cast<uint64>(npdu.dnet), npdu.dadr, cast<uint64>(npdu.snet), npdu.sadr, cast<uint64>(npdu.hop_count), npdu.message_type );
#};

type NPDU_Reject_reason = enum {
  Other = 0,
  No_route = 1,
  Router_busy = 2,
  Unknown_message_type = 3,
  Message_too_long = 4,
  Security_error = 5,
  Addressing_error = 6
};

type NPDU_message = unit(len: uint16, t: NPDU_type) {
  # len only is remaining length
  switch ( t ) {
    NPDU_type::Who-Is-Router-To-Network,
    NPDU_type::Disconnect-Connection-To-Network -> dnets: list<uint16> &length=1 if ( len >= 2 );
    NPDU_type::I-Am-Router-To-Network, 
    NPDU_type::Router-Busy-To-Network,
    NPDU_type::Router-Available-To-Network -> dnets: list<uint16> &length=len / 2;
    NPDU_type::I-Could-Be-Router-To-Network -> {
      dnets: list<uint16> &length=1;
      performance_index: uint8;
    }
    NPDU_type::Reject-Message-To-Network -> {
      reason: uint8 &convert=NPDU_Reject_reason($$);
      dnets: list<uint16> &length=1;
    }
    NPDU_type::Establish-Connection-To-Network -> {
      dnets: list<uint16> &length=1;
      termination_time: uint8;
    }
    NPDU_type::What-Is-Network-Number -> : void; # empty packet
    NPDU_type::Network-Numer-Is -> {
      network_number: uint16;
      learned: uint8;
    }
    NPDU_type::Initialize-Routing-Table,
    NPDU_type::Initialize-Routing-Table-Ack -> {
      number_ports: uint8 if ( len > 0 );
      routing_entries: list<NPDU_routing_entry> &length=1 if ( len > 0 );
    }
  };
};

type NPDU_routing_entry = unit {
  dnet: uint16;
  portId: uint8;
  portInfo_len: uint8;
  portInfo: bytes &length=self.portInfo_len;
};

type PDU_type = enum {
  ConfirmedRequest = 0,
  Unconfirmed-Request = 1,
  SimpleAck = 2,
  ComplexAck = 3,
  SegmentAck = 4,
  Error = 5,
  Reject = 5,
  Abort = 7
};

type APDU = unit(len: uint16) {
  # ok, the first 4 bits contain the actual message type - but we need them later.
  head: bytes &length = 1;
  var tpe: PDU_type;
  tpe_raw: uint8 &parse(self.head) {
    self.tpe_raw = (self.tpe_raw & 0xF0) >> 4;
    self.tpe = PDU_type(self.tpe_raw);
  }

  switch ( self.tpe ) {
    PDU_type::ConfirmedRequest -> confirmed_request: PDU_confirmedRequest(self.head, len);
    PDU_type::Unconfirmed-Request -> unconfirmed_request: PDU_unconfirmedRequest(len);
    PDU_type::SimpleAck -> simple_ack: PDU_simpleACK;
    PDU_type::ComplexAck -> complex_ack: PDU_complexAck(self.head, len);
    PDU_type::Error -> error: PDU_error;
    PDU_type::Reject -> reject: PDU_reject;
    PDU_type::Abort -> abort: PDU_abort(self.head);
  };

};

type BACnetConfirmedServiceChoice = enum {
  # Alarm and Event Services
  acknowledgeAlarm = 0,
  confirmedCOVNotification = 1,
  confirmedEventNotification = 2,
  getAlarmSummary = 3,
  getEnrollmentSummary = 4,
  getEventInformation = 29,
  subscribeCOV = 5,
  subscribeCOVProperty = 28,
  lifeSafetyOperation = 27,
  # File Access Services
  atomicReadFile = 6,
  atomicWriteFile = 7,
  # Object Access Services
  addListElement = 8,
  removeListElement = 9,
  createObject = 10,
  deleteObject = 11,
  readProperty = 12,
  readPropertyMultiple = 14,
  readRange = 26,
  writeProperty = 15,
  writePropertyMultiple = 16,
  # Remote Device Management Services
  deviceCommunicationControl = 17,
  confirmedPrivateTransfer = 18,
  confirmedTextMessage = 19,
  reinitializeDevice = 20,
  # Virtual Terminal Services
  vtOpen = 21,
  vtClose = 22,
  vtData = 23
};

type PDU_confirmedRequest = unit(head: bytes, len: uint16) {
  var len: uint16 = 4;

  head1 : bitfield(8) {
    segmented-response-accepted: 1;
    more-follows: 2;
    segmented-message: 3;
    tpe: 4..7;
  } &parse(head) {
    if ( self.head1.segmented-message == 1 ) {
      self.len = self.len + 2;
    }
  }
  head2: bitfield(8) {
    max-APDU-length-accepted: 0..3;
    max-segments-accepted: 4..6;
  };

  invokeID: uint8;
  sequence_number: uint8 if ( self.head1.segmented-message == 1 );
  proposed_window_size: uint8 if ( self.head1.segmented-message == 1 );
  confirmed_service_choice: uint8 &convert=BACnetConfirmedServiceChoice($$);

  switch ( self.confirmed_service_choice ) {
    BACnetConfirmedServiceChoice::confirmedEventNotification -> confirmedEventNotification: ConfirmedEventNotification_Request( len - self.len );
    BACnetConfirmedServiceChoice::readProperty -> readProperty: ReadProperty_Request( len - self.len );
    BACnetConfirmedServiceChoice::writeProperty -> writeProperty: WriteProperty_Request( len - self.len );
    BACnetConfirmedServiceChoice::atomicReadFile -> atomicReadFile: AtomicReadFile_Request;
    BACnetConfirmedServiceChoice::atomicWriteFile -> atomicWriteFile: AtomicWriteFile_Request;
    BACnetConfirmedServiceChoice::readRange -> readRange: ReadRange_Request( len - self.len );
    BACnetConfirmedServiceChoice::confirmedPrivateTransfer -> confirmedPrivateTransfer: ConfirmedPrivateTransfer_Request( len - self.len );
    * -> : void { print "unhandled confirmedrequest", self.confirmed_service_choice; }
  } if ( self.head1.more-follows == 0 && self.head1.segmented-message == 0 );
};

type ReadRange_Request = unit(len: uint16) {
  # context specific tags 0-6, last few optional choice
  first_tag: BACnetTag;
  objectIdentifier: BACnetContextMessage(BACnetType::BACnetObjectIdentifier, 0, self.first_tag);
  var propertyIdentifier: BACnetPropertyIdentifier;
  propertyIdentifier_raw: BACnetContextMessage(BACnetType::Enumerated, 1, self.objectIdentifier.tag) {
    self.propertyIdentifier = BACnetPropertyIdentifier(self.propertyIdentifier_raw.unsigned);
  }
  propertyArrayIndex: BACnetContextMessage(BACnetType::UnsignedInteger, 2, self.propertyIdentifier_raw.tag);
  # Range
  range: BACnetTag if ( len > self.offset() );
  ## byPosition - 3
  ## 4 and 5 are deprecated
  ## bySequenceNumber - 6
  ## byTime - 7
  
  # types vary by range choice.
  reference: BACnetMessage if ( len > self.offset() );
  count: BACnetMessage if ( len > self.offset() ); # integer16 optional
};

type ConfirmedPrivateTransfer_Request = unit(len: uint16) {
  # context specific tags 0-2, last optional
  first_tag: BACnetTag;
  vendorID: BACnetContextMessage(BACnetType::UnsignedInteger, 0, self.first_tag);
  serviceNumber: BACnetContextMessage(BACnetType::UnsignedInteger, 1, self.vendorID.tag);
  serviceParameters: BACnetArray if ( len > self.offset() ); # ABSTRACT-SYNTAX.&Type OPTIONAL
};

type ConfirmedEventNotification_Request = unit(len: uint16) {
  # context-specific tags 0 - 12
  first_tag: BACnetTag;
  processIdentifier: BACnetContextMessage(BACnetType::UnsignedInteger, 0, self.first_tag);
  initiatingDeviceIdentifier: BACnetContextMessage(BACnetType::BACnetObjectIdentifier, 1, self.processIdentifier.tag);
  eventObjectIdentifier: BACnetContextMessage(BACnetType::BACnetObjectIdentifier, 2, self.initiatingDeviceIdentifier.tag);
  timeStamp_tag: BACnetTag; # wrapped timestamp
  timeStamp: BACnetTimeStamp;
  : BACnetTag if ( self.timeStamp_tag.lvt == 6 ); # end tag, has to have tag == 3
  notificationClass: BACnetContextMessage(BACnetType::UnsignedInteger, 4, self.timeStamp_tag);
  priority: BACnetContextMessage(BACnetType::UnsignedInteger, 5, self.notificationClass.tag);
  var eventType: BACnetEventType;
  eventType_raw: BACnetContextMessage(BACnetType::Enumerated, 6, self.priority.tag) { # BACnetEventType
    self.eventType = BACnetEventType(self.eventType_raw.unsigned);
  }
  messageText: BACnetContextMessage(BACnetType::CharacterString, 7, self.eventType_raw.tag); # optional
  var notifyType: BACnetNotifyType;
  notifyType_raw: BACnetContextMessage(BACnetType::Enumerated, 8, self.messageText.tag) { # BACnetNotifyType,
    self.notifyType = BACnetNotifyType(self.notifyType_raw.unsigned);
  }
  ackRequired: BACnetContextMessage(BACnetType::BOOLEAN, 9, self.notifyType_raw.tag);
  var fromState: BACnetEventState;
  fromState_raw: BACnetContextMessage(BACnetType::Enumerated, 10, self.ackRequired.tag) { # BACnetEventState, optional
    if ( self.fromState_raw.tag.tag == 10 ) {
      self.fromState = BACnetEventState(self.fromState_raw.unsigned);
    }
  }
  toState_raw: BACnetContextMessage(BACnetType::Enumerated, 11, self.fromState_raw.tag); # BACnetEventState, not optional
#  eventValues: ... if ( len > self.offset() ); # BACnetNotificationParameters, optional # Fixme: we do not handle the BACnetNotificationParameters yet
#
};
#
# Enums to handle bacnetnotificationparameters:
# 
# BACnetPropertyStates,
# BACnetLifeSafetyState,
# BACnetLifeSafetyMode,
# BACnetLifeSafetyOperation
# BACnetDeviceObjectPropertyValue
# BACnetDeviceObjectPropertyReference,
# BACnetAccessEvent,
# BACnetStatusFlags,
# BACnetDeviceObjectReference,
# BACnetAuthenticationFactor
# BACnetReliability,

type AtomicReadFile_Request = unit {
  fileIdentifier: BACnetMessage; # oid
  # choice. Opening tag
  open_tag: BACnetTag;

  # streamAccess
    fileStartPosition: BACnetMessage if ( self.open_tag.tag == 0 ); # integer
    requestedOctetCount: BACnetMessage if ( self.open_tag.tag == 0 ); # unsigned
  
  # recordAccess
    fileStartRecord: BACnetMessage if ( self.open_tag.tag == 1 ); # integer
    requestedRecordCount: BACnetMessage if ( self.open_tag.tag == 1 ); # unsigned
  # close tag
   : BACnetTag;
};

type AtomicWriteFile_Request = unit {
  fileIdentifier: BACnetMessage; # oid
  # choice. Opening tag
  open_tag: BACnetTag;

  # streamAccess
  	fileStartPosition: BACnetMessage if ( self.open_tag.tag == 0 ); # integer
	FileData: BACnetMessage if ( self.open_tag.tag == 0 ); # octet string
  
  # recordAccess
  	fileStartRecord: BACnetMessage if ( self.open_tag.tag == 1 ); # integer
	recordCount: BACnetMessage if ( self.open_tag.tag == 1 ); # unsigned
	# sequence of octet string
	fileRecordData: BACnetArray if ( self.open_tag.tag == 1 );
  # close Tag
   : BACnetTag;
};

type ReadProperty_Request = unit(len: uint16) {
  # context-specific tags 0 - 2
  first_tag: BACnetTag;
  objectIdentifier: BACnetContextMessage(BACnetType::BACnetObjectIdentifier, 0, self.first_tag);
  propertyIdentifier_tag: BACnetTag;
  propertyIdentifier: bytes &length=self.propertyIdentifier_tag.lvt &convert=BACnetPropertyIdentifier($$.to_uint(BinPAC::ByteOrder::Network));
  propertyArrayIndex: BACnetContextMessage(BACnetType::UnsignedInteger, 2, self.propertyIdentifier_tag) if ( len > self.offset() );
};

type WriteProperty_Request = unit(len: uint16) {
  # context-specific tags 0 - 4
  first_tag: BACnetTag;
  objectIdentifier: BACnetContextMessage(BACnetType::BACnetObjectIdentifier, 0, self.first_tag);
  propertyIdentifier_tag: BACnetTag; # tag 1
  propertyIdentifier: bytes &length=self.propertyIdentifier_tag.lvt &convert=BACnetPropertyIdentifier($$.to_uint(BinPAC::ByteOrder::Network));
  propertyArrayIndex: BACnetContextMessage(BACnetType::UnsignedInteger, 2, self.propertyIdentifier_tag);
  propertyValue_tag: BACnetTag if ( self.propertyArrayIndex.tag.tag != 3 ); # check if previous tag was optional. This tag = 3
  propertyValue: BACnetArray_Partial(3);
  priority: BACnetContextMessage(BACnetType::UnsignedInteger, 4, self.first_tag) if ( len > self.offset() );
};

type BACnetUnconfirmedServiceChoice = enum {
  i-Am = 0,
  i-Have = 1,
  unconfirmedCOVNotification = 2,
  unconfirmedEventNotification = 3,
  unconfirmedPrivateTransfer = 4,
  unconfirmedTextMessage = 5,
  timeSynchronization = 6,
  who-Has = 7,
  who-Is = 8,
  utcTimeSynchronization = 9,
  writeGroup = 10
};

type PDU_unconfirmedRequest = unit(len: uint16) {
  service_choice: uint8 &convert=BACnetUnconfirmedServiceChoice($$);

  switch ( self.service_choice ) {
    BACnetUnconfirmedServiceChoice::i-Am -> i_am: I_Am_Request;
    BACnetUnconfirmedServiceChoice::unconfirmedCOVNotification -> unconfirmedCOVNotification: UnconfirmedCOVNotification_Request(len - 2);    
#    BACnetUnconfirmedServiceChoice::unconfirmedEventNotification -> unconfirmedEventNotification: PDU_UnconfirmedEventNotification(len - 2);    
    BACnetUnconfirmedServiceChoice::unconfirmedPrivateTransfer -> unconfirmedPrivateTransfer: UnconfirmedPrivateTransfer_Request(len - 2);    
    BACnetUnconfirmedServiceChoice::who-Is -> who_is: Who_Is_Request(len - 2);
    BACnetUnconfirmedServiceChoice::who-Has -> who_has: Who_Has_Request(len - 2);
    * -> : void { print "unhandled unconfirmedconfirmedrequest", self.service_choice; }
  };
};

type Who_Is_Request = unit(len: uint16) {
  tag: BACnetTag if ( len > 0 ); # context specific - has to be tag 0
  deviceInstanceRangeLowLimit: uint16 if ( len > 0 );
  tag2: BACnetTag if ( len > 0 ); # context specific - has to be tag 1
  deviceInstanceRangeHighLimit: uint16 if ( len > 0);
};

type Who_Has_Request = unit(len: uint16) {
  # context specific tags 0 - 3
  first_tag: BACnetTag;
  deviceInstanceRangeLowLimit: BACnetContextMessage(BACnetType::UnsignedInteger, 0, self.first_tag);
  deviceInstanceRangeHighLimit: BACnetContextMessage(BACnetType::UnsignedInteger, 1, self.deviceInstanceRangeLowLimit.tag);
  objectIdentifier: BACnetContextMessage(BACnetType::BACnetObjectIdentifier, 2, self.deviceInstanceRangeHighLimit.tag);
  objectName: BACnetContextMessage(BACnetType::CharacterString, 3, self.objectIdentifier.tag);
};

type I_Am_Request = unit {
  iAmDeviceIdentifier: BACnetMessage; # oid 
  maxAPDULengthAccepted: BACnetMessage; # unsigned 
  segmentationSupported: BACnetMessage; # BACnetSegmentation
  vendorID: BACnetMessage; # unsigned16
};

type UnconfirmedPrivateTransfer_Request = unit(len: uint16) {
  # context specific tags 0-2, last optional
  first_tag: BACnetTag;
  vendorID: BACnetContextMessage(BACnetType::UnsignedInteger, 0, self.first_tag);
  serviceNumber: BACnetContextMessage(BACnetType::UnsignedInteger, 1, self.vendorID.tag);
  serviceParameters: BACnetArray if ( len > self.offset() ); # ABSTRACT-SYNTAX.&Type OPTIONAL
};

type UnconfirmedCOVNotification_Request = unit(len: uint16) {
  # context specific tags 0-4.
  first_tag: BACnetTag;
  subscriberProcessIdentifier: BACnetContextMessage(BACnetType::UnsignedInteger, 0, self.first_tag);
  initiatingDeviceIdentifier: BACnetContextMessage(BACnetType::BACnetObjectIdentifier, 1, self.subscriberProcessIdentifier.tag);
  monitoredObjectIdentifier: BACnetContextMessage(BACnetType::BACnetObjectIdentifier, 2, self.initiatingDeviceIdentifier.tag);
  timeRemaining: BACnetContextMessage(BACnetType::UnsignedInteger, 3, self.monitoredObjectIdentifier.tag);
  listOfValues: BACnetArray; # Sequence of BACnetPropertyValue
};

#type PDU_UnconfirmedEventNotification = unit(len: uint16) {
#  : BACnetTag;
#  processIdentifier : uint32;
#  : BACnetTag;
#  initiatingDeviceIdentifier: BACnetObjectIdentifier
#  : BACnetTag;
#  BACnetObjectIdentifier: BACnetObjectIdentifier
#  : BACnetTag;
#  timeStamp: BACnetTimeStamp;
#  notificationClass_tag: BACnetTag;
#  notificationClass: bytes &length=notificationClass_tag.lvt &convert=$$.to_uint(BinPAC::ByteOrder::Network); 
#  : BACnetTag;
#  priority: uint8;
#  : BACnetTag;
#  eventType: BACnetEventType;
#  : BACnetTag;
#  # tag 7 messageText character string optional
#};

type PDU_simpleACK = unit {
  invokeID: uint8;
  service_choice: uint8 &convert=BACnetConfirmedServiceChoice($$);
};

type PDU_complexAck = unit(head_raw: bytes, len: uint16) {
  var len: uint16 = 3;

  head : bitfield(8) {
    more-follows: 2;
    segmented-message: 3;
    tpe: 4..7;
  } &parse(head_raw) {
    if ( self.head.segmented-message == 1 ) {
      self.len = self.len + 2;
    }
  }
  invokeID: uint8;
  sequence_number: uint8 if ( self.head.segmented-message == 1 );
  proposed_window_size: uint8 if ( self.head.segmented-message == 1 );
  confirmed_service_choice: uint8 &convert=BACnetConfirmedServiceChoice($$); 

  # Fixme: segmentation handling

  switch ( self.confirmed_service_choice ) {
    BACnetConfirmedServiceChoice::readProperty -> readProperty: ReadProperty_ACK;
    BACnetConfirmedServiceChoice::atomicReadFile -> atomicReadFile: AtomicReadFile_ACK;
    BACnetConfirmedServiceChoice::atomicWriteFile -> atomicWriteFile: AtomicWriteFile_ACK;
    BACnetConfirmedServiceChoice::confirmedPrivateTransfer -> confirmedPrivateTransfer: ConfirmedPrivateTransfer_ACK( len - self.len );
    BACnetConfirmedServiceChoice::readRange -> readRange: ReadRange_ACK( len - self.len );
    * -> : void { print "unhandled complexAck", self.confirmed_service_choice; } # Fixme: missing cases
  } if ( self.head.more-follows == 0 && self.head.segmented-message == 0 ); # only parse message if we are in last chunk/single-chunk
};

type ReadRange_ACK = unit(len: uint16) {
  # context specific tags 0-6, last optional
  first_tag: BACnetTag;
  objectIdentifier: BACnetContextMessage(BACnetType::BACnetObjectIdentifier, 0, self.first_tag);
  var propertyIdentifier: BACnetPropertyIdentifier;
  propertyIdentifier_raw: BACnetContextMessage(BACnetType::Enumerated, 1, self.objectIdentifier.tag) {
    self.propertyIdentifier = BACnetPropertyIdentifier(self.propertyIdentifier_raw.unsigned);
  }
  propertyArrayIndex: BACnetContextMessage(BACnetType::UnsignedInteger, 2, self.propertyIdentifier_raw.tag);
  #var resultFlags: BACnetResultFlags;
  resultFlags: BACnetContextMessage(BACnetType::BitString, 3, self.propertyArrayIndex.tag); # Fixme: unparsed (bitstring) {
  #  self.resultFlags = BACnetResultFlags(self.resultFlags_raw.unsigned);
  #}
  itemCount: BACnetContextMessage(BACnetType::UnsignedInteger, 4, self.resultFlags.tag);
  itemData: BACnetArray;
  test: uint8;
  firstSequenceNumber: BACnetContextMessage(BACnetType::UnsignedInteger, 6, self.itemData.begin) if ( len > self.offset() );
};

type ConfirmedPrivateTransfer_ACK = unit(len: uint16) {
  # context specific tags 0-2, last optional
  first_tag: BACnetTag;
  vendorID: BACnetContextMessage(BACnetType::UnsignedInteger, 0, self.first_tag);
  serviceNumber: BACnetContextMessage(BACnetType::UnsignedInteger, 1, self.vendorID.tag);
  resultBlock: BACnetArray if ( len > self.offset() ); # ABSTRACT-SYNTAX.&Type OPTIONAL
};

type AtomicReadFile_ACK = unit {
  endOfFile: BACnetMessage; # boolean
  # choice. Opening tag
  open_tag: BACnetTag;

  # streamAccess
    fileStartPosition: BACnetMessage if ( self.open_tag.tag == 0 ); # integer
    fileData: BACnetMessage if ( self.open_tag.tag == 0 ); # octet String
  
  # recordAccess
    fileStartRecord: BACnetMessage if ( self.open_tag.tag == 1 ); # integer
    fileRecordCount: BACnetMessage if ( self.open_tag.tag == 1 ); # unsigned
    # sequence of octet string
    fileRecordData: BACnetArray if ( self.open_tag.tag == 1 );	
  # close tag
   : BACnetTag;
};

type AtomicWriteFile_ACK = unit {
  first_tag: BACnetTag;
  fileStartPosition: BACnetContextMessage(BACnetType::Integer, 0, self.first_tag);
  FileStartRecord: BACnetContextMessage(BACnetType::Integer, 0, self.fileStartPosition.tag);
};

type ReadProperty_ACK = unit {
  # context-specific tags 0 - 3
  first_tag: BACnetTag;
  objectIdentifier: BACnetContextMessage(BACnetType::BACnetObjectIdentifier, 0, self.first_tag);
  propertyIdentifier_tag: BACnetTag;
  propertyIdentifier: bytes &length=self.propertyIdentifier_tag.lvt &convert=BACnetPropertyIdentifier($$.to_uint(BinPAC::ByteOrder::Network));
  propertyArrayIndex: BACnetContextMessage(BACnetType::UnsignedInteger, 2, self.propertyIdentifier_tag);
  propertyValue_tag: BACnetTag if ( self.propertyArrayIndex.tag.tag != 3 ); # check if previous tag was optional. This tag = 3
  propertyValue: BACnetArray_Partial(3);
};

type PDU_error = unit {
  invokeID: uint8;
  error-class: uint8;
  error-code: uint8;
  # conversion codes -> standard;
};

type BACnetRejectReason = enum {
  other = 0,
  buffer-overflow = 1,
  inconsistent-parameters = 2,
  invalid-parameter-data-type = 3,
  invalid-tag = 4,
  missing-required-parameter = 5,
  parameter-out-of-range = 6,
  too-many-arguments = 7,
  undefined-enumeration = 8,
  unrecognized-service = 9
};

type PDU_reject = unit {
  invokeID: uint8;
  reject_reason: uint8 &convert=BACnetAbortReason($$);
};

type BACnetAbortReason = enum {
  other = 0,
  buffer-overflow = 1,
  invalid-apdu-in-this-state = 2,
  preempted-by-higher-priority-task = 3,
  segmentation-not-supported = 4,
  security-error = 5,
  insufficient-security = 6,
  window-size-out-of-range = 7,
  application-exceeded-reply-time = 8,
  out-of-resources = 9,
  tsm-timeout = 10,
  apdu-too-long = 11
};

type PDU_abort = unit(head_raw: bytes) { # page 624
  head : bitfield(8) {
    server: 0;
    tpe: 4..7;
  } &parse(head_raw);
  invokeID: uint8;
  abort_reason: uint8 &convert=BACnetAbortReason($$); # pg. 652
};

type ASN1Class = enum {
  UNIVERSAL = 0,
  APPLICATION = 1,
  context-specific = 2,
  PRIVATE = 3
};

type BACnetType = enum {
  NULL = 0,
  BOOLEAN = 1,
  UnsignedInteger = 2,
  Integer = 3,
  Real = 4,
  Double = 5,
  OctetString = 6,
  CharacterString = 7,
  BitString = 8,
  Enumerated = 9,
  Date = 10,
  Time = 11,
  BACnetObjectIdentifier = 12
};

type BACnetTag = unit {
  var tpe: BACnetType;
  var class: ASN1Class;

  data : bitfield(8) {
     lvt: 0..2;
     class: 3;
     tag: 4..7;
  } &bitorder=BinPAC::BitOrder::LSB0;

  tag: uint8 if ( self.data.tag == 0xF );
  lvt: uint8 if ( self.data.lvt == 0x5 );
  # length/value/type.
  # for context-specific, a length of 6 means an open tag, a length of 7 means
  # a close-tag.
  # The close tag needs to be context-specific too and have the same tag-value
  # as the opening tag.

  on %done { 
    if ( self.data.tag != 0xF ) {
      self.tag = self.data.tag;
    }
    if ( self.data.lvt != 0x5 ) {
      self.lvt = self.data.lvt;
    }
    self.tpe = BACnetType(self.tag);
    self.class = ASN1Class(self.data.class + 1); # bacnet only has application / context-specific
  }
};

# This is a unit to make my live when parsing bacnet a little bit easier.
# In many cases, we have a number of context-specific tags, of which a few are optional.
# When a tag is optional, the next tag is only parsed when the optional tag was present, otherwhise
# it basically is skipped. This unit is used for the tag _after_ an optional tag. 
# If the tag number of the passed(previous) tag is the tag-number of this tag, it returns the old
# tag again. Otherwhise it reads the tag from the wire.
# type OptionalBACnetTag = unit(tag: BACnetTag, expect: uint8) {
#  var tag: BACnetTag;
#  
#  tag_raw: BACnetTag if ( tag.tag != expect );
#
#  on %done {
#    if ( tag != expect ) {
#      self.tag = self.tag_raw;
#    } else {
#      self.tag = tag;
#    }
#  }
#};

type BACnetArray_Partial = unit(tag: uint8) { # BACnetArray without the beginning tag (we alrady read that)
  # start tag of the array.
  # Fixme: bail out if the tag is not context-specific
  # Fixme: bail out if self.begin.lvt != 6
  #begin: BACnetTag;
  value: list<BACnetMessage> &until( ( $$.tag.class == ASN1Class::context-specific ) &&
                                     ( $$.tag.lvt == 7 ) &&
                                     ( $$.tag.tag == tag ) );
};

type BACnetArray = unit { #
  # start tag of the array.
  # Fixme: bail out if the tag is not context-specific
  # Fixme: bail out if self.begin.lvt != 6
  begin: BACnetTag;
  value: list<BACnetMessage> &until( ( $$.tag.class == ASN1Class::context-specific ) &&
                                     ( $$.tag.lvt == 7 ) &&
                                     ( $$.tag.tag == self.begin.tag ) );
};

type BACnetObjectType = enum { 
  alert-enrollment = 52,
  access-credential = 32,
  access-door = 30,
  access-point = 33,
  access-rights = 34,
  access-user = 35,
  access-zone = 36,
  accumulator = 23,
  analog-input = 0,
  analog-output = 1,
  analog-value = 2,
  averaging = 18,
  binary-input = 3,
  binary-output = 4,
  binary-value = 5,
  bitstring-value = 39,
  calendar = 6,
  channel = 53,
  characterstring-value = 40,
  command = 7,
  credential-data-input = 37,
  date-pattern-value = 41,
  date-value = 42,
  datetime-pattern-value = 43,
  datetime-value = 44,
  device = 8,
  event-enrollment = 9,
  event-log = 25,
  bacnet-file = 10,  # original name: file
  global-group = 26,
  group = 11,
  integer-value = 45,
  large-analog-value = 46,
  life-safety-point = 21,
  life-safety-zone = 22,
  lighting-output = 54,
  load-control = 28,
  loop = 12,
  multi-state-input = 13,
  multi-state-output = 14,
  multi-state-value = 19,
  network-security = 38,
  notification-class = 15,
  notification-forwarder = 51,
  octetstring-value = 47,
  positive-integer-value = 48,
  program = 16,
  pulse-converter = 24,
  schedule = 17,
  structured-view = 29,
  time-pattern-value = 49,
  time-value = 50,
  trend-log = 20,
  trend-log-multiple = 27
};

# Fixme: need to get the type mapping from somewhere, probably the standard...
type BACnetObjectIdentifier = unit {
  var tpe: BACnetObjectType;

  data: bitfield(32) {
    instanceNumer: 0..21;
    tpe: 22..31;
  } { 
    self.tpe = BACnetObjectType(self.data.tpe);
  }
};

type BACnetMessage = unit {
  tag: BACnetTag;

  var boolean: uint16;

  switch ( self.tag.tpe ) {
    BACnetType::NULL -> : void;
    BACnetType::BOOLEAN -> : void { self.boolean = self.tag.lvt; }
    BACnetType::UnsignedInteger,
    BACnetType::Enumerated -> unsigned: bytes &length=self.tag.lvt &convert=$$.to_uint(BinPAC::ByteOrder::Network);
    BACnetType::Integer -> signed: bytes &length=self.tag.lvt &convert=$$.to_int(BinPAC::ByteOrder::Network);
    BACnetType::OctetString -> octets: bytes &length=self.tag.lvt;
    BACnetType::CharacterString -> characters: BACnetCharacterString(self.tag.lvt);
    BACnetType::BitString -> bitstring: BACnetBitString(self.tag.lvt);
    BACnetType::Date -> date: BACnetDate;
    BACnetType::Time -> btime: BACnetTime;
    BACnetType::BACnetObjectIdentifier -> oid: BACnetObjectIdentifier;
    
    # Fixme: Real, double. I don't think Binpac++ can read those from wire yet.
    BACnetType::Real -> : bytes &length = 4;
    BACnetType::Double -> : bytes &length = 8;
  } if ( self.tag.class == ASN1Class::APPLICATION); 
  # skip parsing if we do not have an application tag. Usually, this should only happen when we are parsing
  # arrays. There the last tag will be context-specific and we use it to abort.
};

# This basically is a plain copy of the unit from above. Once I get default arguments, it will be easy to get
# rid of this :)
# tpe: type we expect
# tag: tag number we expect. If this does not match, skip
# prev_tag: the previous tag. If the tag number we expect matches the previous tag, take the previous tag.
# Assume correct ordering of tags. I think we always have that in BACnet...
type BACnetContextMessage = unit(tpe: BACnetType, tag: uint8, prev_tag: BACnetTag) {
  var tag: BACnetTag;

  tag_new: BACnetTag if ( prev_tag.tag < tag ); # only if the old tag does not match what we want.

  : void { # sorry, abusing void just works too well here :)
    if ( prev_tag.tag < tag ) {
      self.tag = self.tag_new;
    } else {
      self.tag = prev_tag;
    }
  }

  var boolean: uint16;

  switch ( tpe ) {
    BACnetType::NULL -> : void;
    BACnetType::BOOLEAN -> : void { self.boolean = self.tag.lvt; }
    BACnetType::UnsignedInteger,
    BACnetType::Enumerated -> unsigned: bytes &length=self.tag.lvt &convert=$$.to_uint(BinPAC::ByteOrder::Network);
    BACnetType::Integer -> signed: bytes &length=self.tag.lvt &convert=$$.to_int(BinPAC::ByteOrder::Network);
    BACnetType::OctetString -> octets: bytes &length=self.tag.lvt;
    BACnetType::CharacterString -> characters: BACnetCharacterString(self.tag.lvt);
    BACnetType::BitString -> bistring: BACnetBitString(self.tag.lvt);
    BACnetType::Date -> date: BACnetDate;
    BACnetType::Time -> btime: BACnetTime;
    BACnetType::BACnetObjectIdentifier -> oid: BACnetObjectIdentifier;
    
    # Fixme: Real, double. I don't think Binpac++ can read those from wire yet.
    BACnetType::Real -> : bytes &length = 4;
    BACnetType::Double -> : bytes &length = 8;
  } if ( self.tag.tag == tag );
  # this check is in case we get optional tags. In this case we may not read the data because it probably will not fit.
};

type BACnetDateTime = unit {
  date: BACnetMessage; 
  btime: BACnetMessage;
};

type BACnetTimeStamp = unit {
  # choice
  tag: BACnetTag;

  btime: BACnetTime if ( self.tag.tag == 0 );
  sequenceNumber: bytes &length=self.tag.lvt &convert=$$.to_uint(BinPAC::ByteOrder::Network) if ( self.tag.tag == 1);
  dateTime: BACnetDateTime if ( self.tag.tag == 2 );

  : BACnetTag if ( self.tag.lvt == 6 );
};

type BACnetDate = unit {
  # a value of 0xFF in any field means wildcard.

  var year: uint16;
  year_raw: uint8 {
    if ( self.year_raw != 0xFF ) {
      self.year = self.year_raw;
      self.year = self.year + 1900;
    } else {
      self.year = 0; # unspecified
    }
  }

  month: uint8;
  day: uint8;
  weekday: uint8; # monday = 1 
};

type BACnetTime = unit {
  # a value of 0xFF in any field means wildcard.
  hour: uint8;
  minute: uint8;
  second: uint8;
  centisecond: uint8;
};

type BACnetCharacterStringType = enum {
  UTF8 = 0,
  DBCS = 1,
  JISX0208 = 2,
  UCS4 = 3,
  UCS2 = 4,
  ISO00591 = 5
};

type BACnetCharacterString = unit(len: uint16) {
  tpe: uint8 &convert=BACnetCharacterStringType($$);

  switch ( self.tpe ) {
    # LE and BE could be switched, not quite sure...
    BACnetCharacterStringType::UTF8 -> value: bytes &length=(len - 1) &convert=$$.decode(BinPAC::Charset::UTF8); 
    BACnetCharacterStringType::UCS2 -> value: bytes &length=(len - 1) &convert=$$.decode(BinPAC::Charset::UTF16BE); 
    BACnetCharacterStringType::UCS4 -> value: bytes &length=(len - 1) &convert=$$.decode(BinPAC::Charset::UTF32BE); 
    * -> value: bytes &length=(len - 1) &convert=$$.decode(BinPAC::Charset::ASCII); # Fixme: DBCS, JOSX0208, ISO885901
  };
  
};

type BACnetBitString = unit(len: uint16) {
   unused_bits: uint8;
   value_bits: bytes &length=(len - 1);
};

