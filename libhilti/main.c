///
/// Implementation of main() which directly calls first hilti_init() and then
/// Main::run().

#include <stdio.h>
#include <string.h>
#include <getopt.h>

#include <sys/wait.h>

#include "types.h"
#include "config.h"
#include "context.h"
#include "globals.h"

// Top-level function generated by HILTI compiler. The user can define this
// function when linking with libhiltimain to provide an entry point. We
// declare out implementation weak so any external one will override it.
__attribute__ ((weak))  void main_run(hlt_exception** excpt, hlt_execution_context* ctx)
{
}

static void usage(const char* prog)
{
    printf("%s [options]\n"
           "\n"
           "  -h| --help           Show usage information.\n"
           "  -t| --threads <num>  Number of worker threads; zero disables. [Default: 2.]\n"
           "  -P| --profile        Activate profiling support.\n"
           "\n", prog);

    exit(1);
}

static struct option long_options[] = {
    {"threads", required_argument, 0, 't'},
    {"profile", no_argument, 0, 'P'},
    {0, 0, 0, 0}
};

#ifdef DEBUG
static void _check_leaks(const char* prog)
{
#if 0 // Disable for now. We have our own leak checking.
# ifdef DARWIN
    int do_leaks = (getenv("HILTI_LEAKS") || getenv("HILTI_LEAKS_QUIET"));
    int do_leaks_quiet = (getenv("HILTI_LEAKS_QUIET") != 0);

    if ( do_leaks ) {
        // Run the external "leaks" tool to find memory leaks.

        if ( ! do_leaks_quiet )
            fputs("-- libhilti main: Running 'leaks' ...\n", stderr);

        setenv("MallocLogFile", "/dev/null", 1); // No output for the subprocessed.

        const char* p = strrchr(prog, '/');
        if ( p )
            prog = p + 1;

        char log[512];
        snprintf(log, sizeof(log), "%s.%d.leaks.tmp", prog, getpid());

        char cmd[512];
        snprintf(cmd, sizeof(cmd), "/usr/bin/leaks %d | cat >%s", getpid(), log);
        system(cmd);

        snprintf(cmd, sizeof(cmd), "/usr/bin/grep -q ' 0 leaks' %s", log);

        int rc = system(cmd);
        rc = WEXITSTATUS(rc);

        if ( rc > 0 ) {
            fprintf(stderr, "-- libhilti main: leaks did not run through\n");
            fprintf(stderr, "-- libhilti main: Log in file: %s\n", log);

            if ( ! getenv("MallocStackLogging") )
                fputs("-- libhilti main: Set environemt variable MallocStackLogging for backtraces.\n", stderr);

        }
        else {
            if ( ! do_leaks_quiet )
                fprintf(stderr, "-- libhilti main: No leaks found\n");

            unlink(log);
        }
    }
#endif
#endif
}
#endif

// Main() function that's save to call both from an actual main() (like the
// one below), and from JIT.
int __libhilti_main(int argc, char **argv)
    {
#ifdef DEBUG
    //_check_leaks(argv[0]);
#endif

    int threads = 2;
    int profiling = 0;

    // Reset getopt() in case some has already called it (e.g., if we're
    // running JIT).
    hlt_reset_getopt();

    while ( 1 ) {
        char c = getopt_long (argc, argv, "ht:P", long_options, 0);

        if ( c == -1 )
            break;

        switch ( c ) {
          case 't':
            threads = atoi(optarg);
            break;

          case 'P':
            profiling = 1;
            break;

          default:
            usage(argv[0]);
        }
    }

    if ( optind != argc )
        usage(argv[0]);

    hlt_config cfg = *hlt_config_get();
    cfg.num_workers = threads;
    cfg.profiling = profiling;
    hlt_config_set(&cfg);

    hlt_init();

    // hlt_threading_start();

    hlt_execution_context* ctx = hlt_global_execution_context();
    hlt_exception* excpt = 0;
    main_run(&excpt, ctx);

    if ( excpt ) {
        hlt_exception_print_uncaught(excpt, hlt_global_execution_context());
        GC_DTOR(excpt, hlt_exception, ctx);
    }

#ifdef DEBUG
    _check_leaks(argv[0]);
#endif

    return 0;
}

__attribute__ ((weak)) int main(int argc, char **argv)
{
    return __libhilti_main(argc, argv);
}
